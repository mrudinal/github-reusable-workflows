name: "Cloudflare Pages: attach custom domain + redirect pages.dev"

on:
  workflow_call:
    secrets:
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ACCOUNT_ID:
        required: true
      CLOUDFLARE_ZONE_ID:
        required: true

jobs:
  setup:
    runs-on: ubuntu-latest

    steps:
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Configure Cloudflare (DNS + Pages domain + Bulk Redirect)
        shell: bash
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}

          PAGES_PROJECT: ${{ vars.PAGES_PROJECT_NAME }}
          PAGES_DEV_HOST: ${{ vars.PAGES_DEV_HOSTNAME }}
          CUSTOM_DOMAIN: ${{ vars.CUSTOM_DOMAIN }}

          OVERRIDE_LIST_NAME: ${{ vars.BULK_REDIRECT_LIST_NAME }}
          OVERRIDE_RULE_REF: ${{ vars.BULK_REDIRECT_RULE_REF }}
          OVERRIDE_RULESET_NAME: ${{ vars.BULK_REDIRECT_RULESET_NAME }}
          REDIRECT_STATUS_CODE: ${{ vars.REDIRECT_STATUS_CODE }}
        run: |
          set -euo pipefail

          SUMMARY_OK=()
          SUMMARY_WARN=()

          start_group() { echo "::group::$1"; }
          end_group() { echo "::endgroup::"; }
          ok() { echo "✔ $1"; SUMMARY_OK+=("$1"); }
          warn() { echo "! $1"; SUMMARY_WARN+=("$1"); }

          to_identifier() {
            echo "$1" | sed 's/[^A-Za-z0-9_\-]/_/g'
          }

          wait_for_list_bulk_operation() {
            local operation_id="$1"
            local label="$2"

            [[ -n "${operation_id:-}" ]] || die "Missing operation_id for ${label}"

            echo "Waiting for list operation to complete (${label}): ${operation_id}"
            local op_response=""
            for attempt in {1..30}; do
              op_response="$(cf GET "/accounts/${CF_ACCOUNT_ID}/rules/lists/bulk_operations/${operation_id}")"
              echo "$op_response" | jq -e '.success == true' >/dev/null || die "Bulk op status failed: $(echo "$op_response" | jq -c '.errors')"
              local op_status
              op_status="$(echo "$op_response" | jq -r '.result.status')"
              echo "  status=${op_status}"
              if [[ "$op_status" == "completed" ]]; then
                return 0
              fi
              if [[ "$op_status" == "failed" ]]; then
                die "Bulk operation failed (${label}): $(echo "$op_response" | jq -c '.result')"
              fi
              sleep 2
            done

            local final_status
            final_status="$(echo "$op_response" | jq -r '.result.status // empty')"
            die "Bulk operation did not complete (${label}). status=${final_status}"
          }

          cf() {
            local method="$1"
            local path="$2"
            local data="${3:-}"
            local url="https://api.cloudflare.com/client/v4${path}"

            if [[ -n "$data" ]]; then
              curl -sS --request "$method" "$url" \
                --header "Authorization: Bearer ${CF_API_TOKEN}" \
                --header "Content-Type: application/json" \
                --data "$data"
            else
              curl -sS --request "$method" "$url" \
                --header "Authorization: Bearer ${CF_API_TOKEN}" \
                --header "Content-Type: application/json"
            fi
          }

          die() { echo "::error::$1"; exit 1; }

          start_group "0) Validate configuration (vars + secrets)"
          [[ -n "${CF_API_TOKEN:-}" ]] || die "Missing CF_API_TOKEN"
          [[ -n "${CF_ACCOUNT_ID:-}" ]] || die "Missing CF_ACCOUNT_ID"
          [[ -n "${CF_ZONE_ID:-}" ]] || die "Missing CF_ZONE_ID"
          [[ -n "${PAGES_PROJECT:-}" ]] || die "Missing PAGES_PROJECT"
          [[ -n "${PAGES_DEV_HOST:-}" ]] || die "Missing PAGES_DEV_HOST"
          [[ -n "${CUSTOM_DOMAIN:-}" ]] || die "Missing CUSTOM_DOMAIN"
          ok "Required vars/secrets present"
          end_group

          # -------------------------
          # Derive names safely
          # -------------------------
          start_group "Derive names"
          PAGES_DEV_URL="https://${PAGES_DEV_HOST}"
          TARGET_URL="https://${CUSTOM_DOMAIN}"

          STATUS_CODE="${REDIRECT_STATUS_CODE:-301}"
          if ! [[ "$STATUS_CODE" =~ ^(301|302|307|308)$ ]]; then
            die "Invalid REDIRECT_STATUS_CODE: $STATUS_CODE (allowed: 301, 302, 307, 308)"
          fi

          # Cloudflare "list variables" work best with [A-Za-z0-9_]
          # If user didn't provide a list name, generate one from project + domain
          RAW_LIST_NAME="${OVERRIDE_LIST_NAME:-pagesdev_to_${CUSTOM_DOMAIN}}"
          LIST_NAME="$(echo "$RAW_LIST_NAME" | sed 's/[^A-Za-z0-9_]/_/g')"

          RULE_REF_RAW="${OVERRIDE_RULE_REF:-redirect_pagesdev_to_custom_${LIST_NAME}}"
          RULE_REF="$(to_identifier "$RULE_REF_RAW")"
          RULE_DESCRIPTION="${OVERRIDE_RULE_REF:-Redirect ${PAGES_DEV_HOST} to ${CUSTOM_DOMAIN}}"
          RULESET_NAME="${OVERRIDE_RULESET_NAME:-Bulk Redirects (managed by GitHub Actions)}"

          echo "Using:"
          echo "  PAGES_PROJECT=${PAGES_PROJECT}"
          echo "  CUSTOM_DOMAIN=${CUSTOM_DOMAIN}"
          echo "  PAGES_DEV_HOST=${PAGES_DEV_HOST}"
          echo "  LIST_NAME=${LIST_NAME}"
          echo "  RULE_REF=${RULE_REF}"
          echo "  RULE_DESCRIPTION=${RULE_DESCRIPTION}"
          echo "  STATUS_CODE=${STATUS_CODE}"
          ok "Names derived"
          end_group

          # -------------------------
          # 1) Ensure DNS CNAME exists (proxied)
          #    CUSTOM_DOMAIN -> PAGES_DEV_HOST
          # -------------------------
          start_group "1) DNS: ensure proxied CNAME"
          echo "Ensuring DNS CNAME exists (proxied)..."
          dns_search="$(cf GET "/zones/${CF_ZONE_ID}/dns_records?type=CNAME&name=${CUSTOM_DOMAIN}")"
          echo "$dns_search" | jq -e '.success == true' >/dev/null || die "DNS search failed: $(echo "$dns_search" | jq -c '.errors')"

          record_id="$(echo "$dns_search" | jq -r '.result[0].id // empty')"
          existing_dns_content="$(echo "$dns_search" | jq -r '.result[0].content // empty')"
          existing_dns_proxied="$(echo "$dns_search" | jq -r '.result[0].proxied // empty')"

          dns_payload="$(jq -n \
            --arg type "CNAME" \
            --arg name "${CUSTOM_DOMAIN}" \
            --arg content "${PAGES_DEV_HOST}" \
            --argjson ttl 1 \
            --argjson proxied true \
            '{type:$type,name:$name,content:$content,ttl:$ttl,proxied:$proxied}'
          )"

          if [[ -n "$record_id" ]]; then
            if [[ "$existing_dns_content" == "${PAGES_DEV_HOST}" && "$existing_dns_proxied" == "true" ]]; then
              echo "DNS CNAME already correct (id=${record_id}). Skipping update."
              dns_result="$dns_search"
            else
              echo "Updating existing CNAME record id=${record_id}"
              dns_upd="$(cf PUT "/zones/${CF_ZONE_ID}/dns_records/${record_id}" "$dns_payload")"
              echo "$dns_upd" | jq -e '.success == true' >/dev/null || die "DNS update failed: $(echo "$dns_upd" | jq -c '.errors')"
              dns_result="$dns_upd"
            fi
          else
            echo "Creating new CNAME record"
            dns_new="$(cf POST "/zones/${CF_ZONE_ID}/dns_records" "$dns_payload")"
            echo "$dns_new" | jq -e '.success == true' >/dev/null || die "DNS create failed: $(echo "$dns_new" | jq -c '.errors')"
            dns_result="$dns_new"
          fi

          # Verify record content + proxy setting
          actual_content="$(echo "$dns_result" | jq -r '.result.content // empty')"
          actual_proxied="$(echo "$dns_result" | jq -r '.result.proxied // empty')"
          [[ "$actual_content" == "${PAGES_DEV_HOST}" ]] || die "DNS CNAME content mismatch: expected=${PAGES_DEV_HOST}, got=${actual_content}"
          [[ "$actual_proxied" == "true" ]] || die "DNS record is not proxied (proxied must be true)."
          ok "DNS CNAME ensured"
          end_group

          # -------------------------
          # 2) Add CUSTOM_DOMAIN to the Pages project (if missing)
          # -------------------------
          start_group "2) Pages: attach custom domain"
          echo "Ensuring Pages project has CUSTOM_DOMAIN..."
          domain_get="$(cf GET "/accounts/${CF_ACCOUNT_ID}/pages/projects/${PAGES_PROJECT}/domains/${CUSTOM_DOMAIN}")"

          if echo "$domain_get" | jq -e '.success == true' >/dev/null; then
            echo "Pages domain already exists on project."
          else
            echo "Adding domain to Pages project..."
            add_payload="$(jq -n --arg name "${CUSTOM_DOMAIN}" '{name:$name}')"
            domain_add="$(cf POST "/accounts/${CF_ACCOUNT_ID}/pages/projects/${PAGES_PROJECT}/domains" "$add_payload")"
            echo "$domain_add" | jq -e '.success == true' >/dev/null || die "Pages add domain failed: $(echo "$domain_add" | jq -c '.errors')"
          fi

          # Verify it exists now; status may be pending/active depending on TLS issuance.
          domain_get2="$(cf GET "/accounts/${CF_ACCOUNT_ID}/pages/projects/${PAGES_PROJECT}/domains/${CUSTOM_DOMAIN}")"
          echo "$domain_get2" | jq -e '.success == true' >/dev/null || die "Pages domain still not readable after attach: $(echo "$domain_get2" | jq -c '.errors')"
          domain_status="$(echo "$domain_get2" | jq -r '.result.status // "unknown"')"
          echo "Pages domain status: ${domain_status}"
          if [[ "$domain_status" == "failed" || "$domain_status" == "error" ]]; then
            die "Pages domain status indicates failure: ${domain_status}"
          fi
          ok "Pages custom domain attached (status=${domain_status})"

          # Optional: trigger a validation retry (safe/no-op if already active)
          if [[ "$domain_status" == "active" ]]; then
            echo "Pages domain is active; skipping validation retry."
          else
            echo "Retrying domain validation (optional)..."
            domain_retry="$(cf PATCH "/accounts/${CF_ACCOUNT_ID}/pages/projects/${PAGES_PROJECT}/domains/${CUSTOM_DOMAIN}" '{}')"
            if echo "$domain_retry" | jq -e '.success == true' >/dev/null; then
              ok "Pages validation retry requested"
            else
              warn "Pages validation retry not applied (non-fatal)"
            fi
          fi
          end_group

          # -------------------------
          # 3) Ensure Bulk Redirect list exists (kind=redirect)
          # -------------------------
          start_group "3) Bulk Redirects: ensure list"
          echo "Ensuring Bulk Redirect list exists..."
          lists="$(cf GET "/accounts/${CF_ACCOUNT_ID}/rules/lists?per_page=100")"
          echo "$lists" | jq -e '.success == true' >/dev/null || die "List fetch failed: $(echo "$lists" | jq -c '.errors')"

          list_id="$(echo "$lists" | jq -r --arg list_name "${LIST_NAME}" '.result[] | select(.name==$list_name and .kind=="redirect") | .id' | head -n 1)"

          if [[ -z "$list_id" ]]; then
            echo "Creating list ${LIST_NAME}..."
            list_payload="$(jq -n \
              --arg name "${LIST_NAME}" \
              --arg kind "redirect" \
              --arg description "Redirect ${PAGES_DEV_HOST} -> ${CUSTOM_DOMAIN} (managed by GitHub Actions)" \
              '{name:$name,kind:$kind,description:$description}'
            )"
            list_create="$(cf POST "/accounts/${CF_ACCOUNT_ID}/rules/lists" "$list_payload")"
            echo "$list_create" | jq -e '.success == true' >/dev/null || die "List create failed: $(echo "$list_create" | jq -c '.errors')"
            list_id="$(echo "$list_create" | jq -r '.result.id')"
          else
            echo "List already exists: id=${list_id}"
          fi

          [[ -n "$list_id" ]] || die "Bulk Redirect list_id is empty"
          ok "Bulk Redirect list ensured (id=${list_id})"
          end_group

          # -------------------------
          # 4) Upsert list item: redirect pages.dev -> custom domain
          #    (async bulk operation, we poll until completed)
          # -------------------------
          start_group "4) Bulk Redirects: add list item"
          echo "Adding/updating redirect item in list (idempotent)..."

          list_item_already_correct="false"

          desired_source="${PAGES_DEV_URL}/*"
          desired_target="${TARGET_URL}"

          existing_items="$(cf GET "/accounts/${CF_ACCOUNT_ID}/rules/lists/${list_id}/items?per_page=100")"
          echo "$existing_items" | jq -e '.success == true' >/dev/null || die "List items fetch failed: $(echo "$existing_items" | jq -c '.errors')"

          existing_item_id="$(echo "$existing_items" | jq -r --arg source "$desired_source" '.result[]? | select(.redirect.source_url? == $source) | .id' | head -n 1)"
          existing_item_json="$(echo "$existing_items" | jq -c --arg source "$desired_source" '.result[]? | select(.redirect.source_url? == $source)' | head -n 1)"

          if [[ -n "${existing_item_id:-}" ]]; then
            existing_target="$(echo "$existing_item_json" | jq -r '.redirect.target_url // empty')"
            existing_status_code="$(echo "$existing_item_json" | jq -r '.redirect.status_code // empty')"
            existing_preserve_query_string="$(echo "$existing_item_json" | jq -r '.redirect.preserve_query_string // empty')"
            existing_preserve_path_suffix="$(echo "$existing_item_json" | jq -r '.redirect.preserve_path_suffix // empty')"
            existing_subpath_matching="$(echo "$existing_item_json" | jq -r '.redirect.subpath_matching // empty')"
            existing_include_subdomains="$(echo "$existing_item_json" | jq -r '.redirect.include_subdomains // empty')"

            if [[ "$existing_target" == "$desired_target" \
              && "$existing_status_code" == "$STATUS_CODE" \
              && "$existing_preserve_query_string" == "true" \
              && "$existing_preserve_path_suffix" == "true" \
              && "$existing_subpath_matching" == "true" \
              && "$existing_include_subdomains" == "true" ]]; then
              echo "List item already exists with desired configuration (id=${existing_item_id}). Skipping."
              ok "Bulk Redirect list item already correct"
              list_item_already_correct="true"
            else
              echo "List item exists but differs (id=${existing_item_id}). Replacing it..."

              delete_payload="$(jq -n --arg id "$existing_item_id" '[{id:$id}]')"
              delete_resp="$(cf DELETE "/accounts/${CF_ACCOUNT_ID}/rules/lists/${list_id}/items" "$delete_payload")"
              echo "$delete_resp" | jq -e '.success == true' >/dev/null || die "Delete list item failed: $(echo "$delete_resp" | jq -c '.errors')"
              delete_op_id="$(echo "$delete_resp" | jq -r '.result.operation_id // empty')"
              wait_for_list_bulk_operation "$delete_op_id" "delete list item"
              ok "Bulk Redirect list item removed"
            fi
          fi

          if [[ "$list_item_already_correct" != "true" ]]; then
          items_payload="$(jq -n \
            --arg source "${desired_source}" \
            --arg target "${desired_target}" \
            --argjson status_code "${STATUS_CODE}" \
            '[{
              redirect: {
                source_url: $source,
                target_url: $target,
                status_code: $status_code,
                include_subdomains: true,
                subpath_matching: true,
                preserve_query_string: true,
                preserve_path_suffix: true
              }
            }]'
          )"

          items_resp="$(cf POST "/accounts/${CF_ACCOUNT_ID}/rules/lists/${list_id}/items" "$items_payload")"
          echo "$items_resp" | jq -e '.success == true' >/dev/null || die "Add list items failed: $(echo "$items_resp" | jq -c '.errors')"

          op_id="$(echo "$items_resp" | jq -r '.result.operation_id // empty')"
          [[ -n "$op_id" ]] || die "No operation_id returned for list item update."

          wait_for_list_bulk_operation "$op_id" "upsert list item"
          ok "Bulk Redirect list item applied"
          fi

          end_group

          # -------------------------
          # 5) Ensure Bulk Redirect rule exists in account entrypoint ruleset
          #    phase: http_request_redirect
          # -------------------------
          start_group "5) Rulesets: ensure redirect rule"
          echo "Ensuring Bulk Redirect rule exists in http_request_redirect entrypoint..."

          entry="$(cf GET "/accounts/${CF_ACCOUNT_ID}/rulesets/phases/http_request_redirect/entrypoint")"

          list_variable_reference="\$${LIST_NAME}"
          expr="http.request.full_uri in ${list_variable_reference}"

          new_rule="$(jq -n \
            --arg action "redirect" \
            --arg expression "${expr}" \
            --arg description "${RULE_DESCRIPTION}" \
            --arg ref "${RULE_REF}" \
            --arg list_name "${LIST_NAME}" \
            '{
              action: $action,
              expression: $expression,
              description: $description,
              enabled: true,
              ref: $ref,
              action_parameters: {
                from_list: {
                  name: $list_name,
                  key: "http.request.full_uri"
                }
              }
            }'
          )"

          if echo "$entry" | jq -e '.success == true' >/dev/null; then
            ruleset_name="$(echo "$entry" | jq -r '.result.name // empty')"
            ruleset_desc="$(echo "$entry" | jq -r '.result.description // empty')"
            rules="$(echo "$entry" | jq -c '.result.rules // []')"

            existing_rule_index="$(echo "$rules" | jq -r --arg ref "${RULE_REF}" --arg desc "${RULE_DESCRIPTION}" '
              (to_entries | map(select((.value.ref? == $ref) or (.value.description? == $desc))) | .[0].key) // empty
            ' | head -n 1)"

            if [[ -n "${existing_rule_index:-}" ]]; then
              echo "Rule already present (index=${existing_rule_index}). Verifying/updating link to list..."
              existing_rule="$(echo "$rules" | jq -c --argjson index "$existing_rule_index" '.[ $index ]')"

              existing_expression="$(echo "$existing_rule" | jq -r '.expression // empty')"
              existing_list_name="$(echo "$existing_rule" | jq -r '.action_parameters.from_list.name // empty')"
              existing_key="$(echo "$existing_rule" | jq -r '.action_parameters.from_list.key // empty')"

              if [[ "$existing_expression" == "$expr" && "$existing_list_name" == "$LIST_NAME" && "$existing_key" == "http.request.full_uri" ]]; then
                echo "Rule already points to the desired list. Skipping update."
              else
                echo "Updating existing rule to point to list ${LIST_NAME}..."
                updated_rules="$(echo "$rules" | jq --argjson index "$existing_rule_index" --argjson rule_object "$new_rule" '.[$index] = $rule_object')"
                upd_payload="$(jq -n \
                  --arg name "${ruleset_name:-$RULESET_NAME}" \
                  --arg description "${ruleset_desc:-$RULESET_NAME}" \
                  --argjson rules "$updated_rules" \
                  '{name:$name, description:$description, rules:$rules}'
                )"
                upd="$(cf PUT "/accounts/${CF_ACCOUNT_ID}/rulesets/phases/http_request_redirect/entrypoint" "$upd_payload")"
                echo "$upd" | jq -e '.success == true' >/dev/null || die "Ruleset entrypoint update failed: $(echo "$upd" | jq -c '.errors')"
              fi
            else
              echo "Appending rule (ref=${RULE_REF})..."
              updated_rules="$(echo "$rules" | jq --argjson rule_object "$new_rule" '. + [$rule_object]')"
              upd_payload="$(jq -n \
                --arg name "${ruleset_name:-$RULESET_NAME}" \
                --arg description "${ruleset_desc:-$RULESET_NAME}" \
                --argjson rules "$updated_rules" \
                '{name:$name, description:$description, rules:$rules}'
              )"
              upd="$(cf PUT "/accounts/${CF_ACCOUNT_ID}/rulesets/phases/http_request_redirect/entrypoint" "$upd_payload")"
              echo "$upd" | jq -e '.success == true' >/dev/null || die "Ruleset entrypoint update failed: $(echo "$upd" | jq -c '.errors')"
            fi
          else
            echo "No entrypoint ruleset yet. Creating one at the entrypoint..."
            create_payload="$(jq -n \
              --arg name "${RULESET_NAME}" \
              --arg description "${RULESET_NAME}" \
              --argjson rules "$(jq -n --argjson rule_object "$new_rule" '[ $rule_object ]')" \
              '{name:$name, description:$description, rules:$rules}'
            )"
            created="$(cf PUT "/accounts/${CF_ACCOUNT_ID}/rulesets/phases/http_request_redirect/entrypoint" "$create_payload")"
            echo "$created" | jq -e '.success == true' >/dev/null || die "Ruleset entrypoint create failed: $(echo "$created" | jq -c '.errors')"
          fi

          # Verify rule exists now
          entry2="$(cf GET "/accounts/${CF_ACCOUNT_ID}/rulesets/phases/http_request_redirect/entrypoint")"
          echo "$entry2" | jq -e '.success == true' >/dev/null || die "Ruleset entrypoint not readable after update/create: $(echo "$entry2" | jq -c '.errors')"
          has_rule2="$(echo "$entry2" | jq -r --arg ref "${RULE_REF}" 'any(.result.rules[]?; .ref == $ref)')"
          [[ "$has_rule2" == "true" ]] || die "Redirect rule not present after update/create (ref=${RULE_REF})"
          ok "Redirect rule ensured in entrypoint"
          end_group

          # -------------------------
          # 6) HTTP post-check: confirm pages.dev redirects to custom domain
          # -------------------------
          start_group "6) Post-check: HTTP redirect"

          test_path="/__gha_pagesdev_redirect_check"
          test_url_pagesdev="${PAGES_DEV_URL}${test_path}?t=$(date +%s)"
          test_url_custom="${TARGET_URL}${test_path}?t=$(date +%s)"

          echo "Checking redirect: ${test_url_pagesdev} -> ${TARGET_URL}"

          redirect_ok="false"
          for attempt in {1..15}; do
            echo "Attempt ${attempt}/15..."
            headers="$(curl -sS -o /dev/null -D - -I --max-time 15 "$test_url_pagesdev" || true)"
            status_line="$(echo "$headers" | head -n 1 | tr -d '\r')"
            location="$(echo "$headers" | awk 'BEGIN{IGNORECASE=1} /^Location:/{sub(/^Location:[[:space:]]*/,"",$0); gsub(/\r/,"",$0); print; exit}')"

            echo "  ${status_line}"
            echo "  Location: ${location:-<none>}"

            # Accept 301/302/307/308 with Location starting with custom domain
            if echo "$status_line" | grep -Eq 'HTTP/[0-9.]+[[:space:]]+(301|302|307|308)'; then
              if [[ -n "$location" ]] && echo "$location" | grep -Fq "${TARGET_URL}"; then
                redirect_ok="true"
                break
              fi
            fi
            sleep 3
          done

          [[ "$redirect_ok" == "true" ]] || die "pages.dev did not redirect to ${TARGET_URL} after retries."
          ok "pages.dev redirects to custom domain"

          echo "Checking custom domain responds (not a 5xx)..."
          headers2="$(curl -sS -o /dev/null -D - -I --max-time 15 "$test_url_custom" || true)"
          status_line2="$(echo "$headers2" | head -n 1 | tr -d '\r')"
          echo "  ${status_line2}"
          if echo "$status_line2" | grep -Eq 'HTTP/[0-9.]+[[:space:]]+5'; then
            die "Custom domain returned a 5xx during check: ${status_line2}"
          fi
          ok "custom domain is serving HTTP"

          end_group

          # -------------------------
          # Final summary
          # -------------------------
          echo ""
          echo "===== Final summary ====="
          for summary_item in "${SUMMARY_OK[@]}"; do
            echo "✔ ${summary_item}"
          done
          for summary_item in "${SUMMARY_WARN[@]}"; do
            echo "! ${summary_item}"
          done

          echo "Done. Your pages.dev hostname should now redirect to the custom domain."
